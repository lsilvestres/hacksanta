<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="utf-8">
    <title>Pátio 3D (reorganizar)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root { --panel-offset: 0px; }
        html, body { height:100%; margin:0; background:#0e1116; color:#e5e7eb; font-family:system-ui, Segoe UI, Roboto, Arial; }
        #app { position:relative; height:100%; }
        canvas { display:block; width:100%; height:100%; }
        
        /* Painel do grid (colapsável no topo) */
        #gridPanel {
            position:absolute; top:12px; left:12px; right:12px;
            background:#111827dd; border:1px solid #374151; border-radius:8px; z-index:30;
            overflow:hidden;
        }
        #gridPanel summary {
            list-style:none; cursor:pointer; padding:10px 12px; user-select:none;
            display:flex; align-items:center; justify-content:space-between; gap:12px;
        }
        #gridPanel summary::-webkit-details-marker { display:none; }
        /* .chev { transition:transform .2s ease; }
        #gridPanel[open] .chev { transform:rotate(180deg); } */
        .chev { transition: transform .2s ease; display:inline-block; }
        #gridPanel[open] .chev { transform: rotate(90deg); }
        #gridPanel[open] summary { border-bottom:1px solid #374151; }
        .panel-body { padding:10px 12px; }
        .table-wrap { max-height:300px; overflow:auto; border-radius:6px; border:1px solid #374151; }
        table { width:100%; border-collapse:separate; border-spacing:0; font-size:12px; }
        thead th {
            position:sticky; top:0; background:#0f172a; z-index:1;
            text-align:left; padding:8px 10px; border-bottom:1px solid #374151;
        }
        tbody td { padding:8px 10px; border-bottom:1px solid #374151; }
        tbody tr:hover { background:#111827; }
        .sw { width:12px; height:12px; border-radius:3px; border:1px solid #374151; display:inline-block; vertical-align:middle; margin-right:6px; }
        
        #tooltip {
            position:absolute; pointer-events:none; padding:6px 8px; background:#111827cc; color:#f9fafb; 
            border:1px solid #374151; border-radius:6px; font-size:12px; transform:translate(-50%, -120%); display:none; white-space:nowrap;
        }
        #legend {
            position:absolute; top:calc(12px + var(--panel-offset)); left:12px; background:#111827dd; padding:10px 12px; border:1px solid #374151; border-radius:8px; font-size:12px; z-index:10;
        }
        .row { display:flex; gap:8px; align-items:center; margin-top:6px; }
        .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #374151; }
        
        #hud {
            position:absolute; bottom:12px; left:12px; background:#111827dd; padding:8px 10px; border:1px solid #374151; border-radius:8px; font-size:12px; z-index:10;
        }
        #actions {
            position:absolute; top:calc(12px + var(--panel-offset)); right:12px; background:#111827dd; padding:10px 12px; border:1px solid #374151; border-radius:8px; display:flex; gap:8px; z-index:10;
        }
        button {
            background:#1f2937; color:#e5e7eb; border:1px solid #374151; padding:6px 10px; border-radius:6px; cursor:pointer;
        }
        button:hover { background:#111827; }
    </style>
</head>
<body>
    <div id="app">
        <canvas id="gl"></canvas>
        
        <!-- Painel colapsável com grid -->
        <details id="gridPanel">
            <summary>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span class="chev">▸</span>
                    <span id="gridTitle">Contêineres</span>
                </div>
                <div style="opacity:.8; font-size:12px;" id="gridMeta">0 itens</div>
            </summary>
            <div class="panel-body">
                <div class="table-wrap">
                    <table aria-label="Grid de contêineres">
                        <thead>
                            <tr>
                                <th>Container</th>
                                <th>Bay</th>
                                <th>Row</th>
                                <th>Tier</th>
                                <th>Entrada</th>
                                <th>Saída</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="gridBody"></tbody>
                    </table>
                </div>
            </div>
        </details>
        
        <div id="tooltip"></div>
        
        <div id="legend">
            <div><strong>Pátio 3D</strong> — bays × rows × tiers</div>
            <div style="margin-top:6px">Bays: 4, Rows: 4, Tiers: 3</div>
            <div class="row"><div class="swatch" style="background:#60a5fa"></div><div>Saída hoje</div></div>
            <div class="row"><div class="swatch" style="background:#34d399"></div><div>≤ 2 dias</div></div>
            <div class="row"><div class="swatch" style="background:#f59e0b"></div><div>≤ 4 dias</div></div>
            <div class="row"><div class="swatch" style="background:#9ca3af"></div><div>Mais longe</div></div>
        </div>
        
        <div id="actions">
            <button id="btnOpt">Reorganizar (saída)</button>
            <button id="btnOrig">Restaurar original</button>
        </div>
        
        <div id="hud">
            Arraste: orbitar • Shift+arraste: pan • Scroll: zoom
        </div>
    </div>
    <script src="add-container-plugin.js"></script>
    <script>
        (async () => {
            // Estado de dados (original e corrente)
            const originalPatio = await fetch('data/load-patio.json').then(r => r.json());
            let patio = JSON.parse(JSON.stringify(originalPatio)); // corrente mutável
            
            // Helpers de tempo e otimização
            const today = new Date().toISOString().slice(0,10);
            function daysUntil(dateStr){
                const d = new Date(dateStr);
                const t = new Date(today);
                return Math.round((d - t)/(1000*60*60*24));
            }
            function colorForSaida(saida){
                const d = daysUntil(saida);
                if (d <= 0) return [0.38, 0.65, 0.98];
                if (d <= 2) return [0.20, 0.83, 0.60];
                if (d <= 4) return [0.96, 0.62, 0.05];
                return [0.62, 0.64, 0.67];
            }
            function statusLabel(saida){
                const d = daysUntil(saida);
                if (d <= 0) return 'Saída hoje';
                if (d <= 2) return '≤ 2 dias';
                if (d <= 4) return '≤ 4 dias';
                return 'Mais longe';
            }
            
            // Otimização simples
            function optimizeLayout(p, { flipRowAxis = true } = {}){
                const { bays, rows, stacks, data } = p;
                const asc = [...data].sort((a,b)=> a.saida.localeCompare(b.saida));
                const out = [];
                let end = asc.length;
                for (let r = rows; r >= 1 && end > 0; r--) {
                    const rowCap = bays * stacks;
                    const take = Math.min(rowCap, end);
                    const start = end - take;
                    const rowItems = asc.slice(start, end).sort((a,b)=> a.saida.localeCompare(b.saida));
                    end = start;
                    const perBay = Array.from({length: bays}, () => []);
                    let k = 0;
                    for (let layer = stacks; layer >= 1 && k < rowItems.length; layer--) {
                        for (let b = 0; b < bays && k < rowItems.length; b++) {
                            perBay[b].push(rowItems[k++]);
                        }
                    }
                    for (let b = 0; b < bays; b++) {
                        const pile = perBay[b];
                        const n = pile.length;
                        for (let j = 0; j < n; j++) {
                            const c = pile[j];
                            const stack = n - j; // topo primeiro
                            const rowOut = flipRowAxis ? (rows - r + 1) : r;
                            out.push({
                                bay: b+1, row: rowOut, stack,
                                container: c.container, entrada: c.entrada, saida: c.saida
                            });
                        }
                    }
                }
                out.sort((a,b)=> a.bay-b.bay || a.row-b.row || a.stack-b.stack);
                return { bays, rows, stacks, data: out };
            }
            
            // WebGL básico
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
            if (!gl) { alert('WebGL não suportado'); return; }
            function resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const w = canvas.clientWidth || canvas.parentElement.clientWidth;
                const h = canvas.clientHeight || canvas.parentElement.clientHeight;
                canvas.width = Math.floor(w * dpr);
                canvas.height = Math.floor(h * dpr);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize); resize();
            
            function mat4Identity(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
            function mat4Multiply(a,b){
                const o=new Float32Array(16);
                for(let r=0;r<4;r++){ for(let c=0;c<4;c++){ o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c]; } }
                return o;
            }
            function mat4Perspective(fovy, aspect, near, far){
                const f = 1/Math.tan(fovy/2), nf = 1/(near - far);
                const out = new Float32Array(16);
                out[0]=f/aspect; out[5]=f; out[10]=(far+near)*nf; out[11]=-1; out[14]=(2*far*near)*nf;
                return out;
            }
            function mat4Translate(m, v){ const [x,y,z]=v; const t=mat4Identity(); t[12]=x; t[13]=y; t[14]=z; return mat4Multiply(m,t); }
            function mat4LookAt(eye,center,up){
                const [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
                let zx=ex-cx, zy=ey-cy, zz=ez-cz; const zlen=Math.hypot(zx,zy,zz); zx/=zlen; zy/=zlen; zz/=zlen;
                let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx; const xlen=Math.hypot(xx,xy,xz); xx/=xlen; xy/=xlen; xz/=xlen;
                const yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
                const out=new Float32Array(16);
                out[0]=xx; out[1]=yx; out[2]=zx; out[4]=xy; out[5]=yy; out[6]=zy; out[8]=xz; out[9]=yz; out[10]=zz;
                out[12]=-(xx*ex+xy*ey+xz*ez); out[13]=-(yx*ex+yy*ey+yz*ez); out[14]=-(zx*ex+zy*ey+zz*ez); out[15]=1; return out;
            }
            
            const vs = `
  attribute vec3 aPos; attribute vec3 aNormal; attribute vec3 aColor;
  uniform mat4 uProj, uView, uModel; varying vec3 vNormal; varying vec3 vColor;
  void main(){ vec4 world = uModel * vec4(aPos,1.0); vNormal = mat3(uModel) * aNormal; vColor = aColor; gl_Position = uProj * uView * world; }`;
            const fs = `
  precision mediump float; varying vec3 vNormal; varying vec3 vColor; uniform vec3 uLightDir;
  void main(){ vec3 n=normalize(vNormal); float diff=max(dot(n, normalize(-uLightDir)),0.0); vec3 col=vColor*(0.35+0.65*diff); gl_FragColor=vec4(col,1.0); }`;
            function compile(type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
            function program(vsSrc, fsSrc){ const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vsSrc)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fsSrc)); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
            const prog = program(vs, fs); gl.useProgram(prog);
            
            const cube = (() => {
                const p = [
                -0.5,-0.5, 0.5,  0.5,-0.5, 0.5,  0.5, 0.5, 0.5,
                -0.5,-0.5, 0.5,  0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
                -0.5,-0.5,-0.5, -0.5, 0.5,-0.5,  0.5, 0.5,-0.5,
                -0.5,-0.5,-0.5,  0.5, 0.5,-0.5,  0.5,-0.5,-0.5,
                -0.5,-0.5,-0.5, -0.5,-0.5, 0.5, -0.5, 0.5, 0.5,
                -0.5,-0.5,-0.5, -0.5, 0.5, 0.5, -0.5, 0.5,-0.5,
                0.5,-0.5,-0.5,  0.5, 0.5,-0.5,  0.5, 0.5, 0.5,
                0.5,-0.5,-0.5,  0.5, 0.5, 0.5,  0.5,-0.5, 0.5,
                -0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  0.5, 0.5,-0.5,
                -0.5, 0.5, 0.5,  0.5, 0.5,-0.5, -0.5, 0.5,-0.5,
                -0.5,-0.5, 0.5, -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,
                -0.5,-0.5, 0.5,  0.5,-0.5,-0.5,  0.5,-0.5, 0.5,
                ];
                const n = new Array(36).fill(0);
                for(let i=0;i<6;i++){
                    const nx = [0,0,0,-1,1,0][i]||0;
                    const ny = [0,0,0, 0,0,1][i]||0;
                    const nz = [1,-1,0,0,0,0][i]||0;
                    for(let t=0;t<6;t++){ n[(i*18)+t*3+0]=nx; n[(i*18)+t*3+1]=ny; n[(i*18)+t*3+2]=nz; }
                }
                return {positions:new Float32Array(p), normals:new Float32Array(n), verts:36};
            })();
            
            function makeVBO(data, loc, size){
                const buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(loc);
                gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
                return buf;
            }
            
            const aPos = gl.getAttribLocation(prog, 'aPos');
            const aNormal = gl.getAttribLocation(prog, 'aNormal');
            const aColor = gl.getAttribLocation(prog, 'aColor');
            
            const posBuf = makeVBO(cube.positions, aPos, 3);
            const nrmBuf = makeVBO(cube.normals, aNormal, 3);
            const colorBuf = gl.createBuffer();
            
            const uProj = gl.getUniformLocation(prog, 'uProj');
            const uView = gl.getUniformLocation(prog, 'uView');
            const uModel = gl.getUniformLocation(prog, 'uModel');
            const uLightDir = gl.getUniformLocation(prog, 'uLightDir');
            
            // Câmera e controles (pivô no centro entre Bay 2-3 e Row 2-3)
            let yaw = -0.8, pitch = -0.4, dist = 22, target = [0, 2, 0];
            let panX = 0, panY = 0;
            let isDragging = false, lastX = 0, lastY = 0, isPanning = false;
            
            canvas.addEventListener('mousedown', e => { isDragging = true; isPanning = e.shiftKey; lastX=e.clientX; lastY=e.clientY; });
            window.addEventListener('mouseup', () => isDragging=false);
            window.addEventListener('mousemove', e => {
                if(!isDragging) return;
                const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX=e.clientX; lastY=e.clientY;
                if(isPanning){ const panSpeed = 0.01 * dist; panX -= dx*panSpeed; panY += dy*panSpeed; }
                else { yaw -= dx*0.005; pitch -= dy*0.005; pitch = Math.max(-1.4, Math.min(1.4, pitch)); }
            });
            canvas.addEventListener('wheel', e => { dist *= (1 + Math.sign(e.deltaY)*0.1); dist = Math.max(5, Math.min(80, dist)); }, {passive:true});
            
            // Layout e instâncias
            const BAY = patio.bays, ROW = patio.rows, STACK = patio.stacks;
            const cellW = 3.0, cellL = 6.0, cellH = 2.5, gap = 0.3;
            
            // Centraliza o pivô
            const centerX = ((ROW - 1) * (cellW + gap)) / 2;
            const centerZ = ((BAY - 1) * (cellL + gap)) / 2;
            target[0] = centerX; target[2] = centerZ;
            
            let instances = [];
            function rebuildInstances(){
                instances = [];
                const byKey = new Map();
                for(const c of patio.data){ byKey.set(`${c.bay}-${c.row}-${c.stack}`, c); }
                for(let b=1;b<=BAY;b++){
                    for(let r=1;r<=ROW;r++){
                        const x = (r-1)*(cellW+gap);
                        const z = (b-1)*(cellL+gap);
                        instances.push({ kind:'floor', pos:[x, -0.51, z], scale:[cellW,0.02,cellL], color:[0.17,0.20,0.25], meta:{ label:`Bay ${b}, Row ${r}` } });
                        for(let s=1;s<=STACK;s++){
                            const c = byKey.get(`${b}-${r}-${s}`);
                            if(!c) continue;
                            const y = (s-1)*(cellH+0.05) + cellH/2;
                            instances.push({
                                kind:'container',
                                pos:[x,y,z],
                                scale:[cellW*0.95, cellH*0.95, cellL*0.95],
                                color:colorForSaida(c.saida),
                                meta:{...c}
                            });
                        }
                    }
                }
            }
            
            // Grid (tabela)
            const gridBody = document.getElementById('gridBody');
            const gridMeta = document.getElementById('gridMeta');
            const gridPanel = document.getElementById('gridPanel');
            
            function updatePanelOffset(){
                const open = gridPanel.hasAttribute('open');
                const h = open ? gridPanel.getBoundingClientRect().height : gridPanel.querySelector('summary').getBoundingClientRect().height;
                document.documentElement.style.setProperty('--panel-offset', (open ? (h + 8) : (h + 8)) + 'px');
            }
            gridPanel.addEventListener('toggle', updatePanelOffset);
            window.addEventListener('resize', updatePanelOffset);
            
            function rebuildGrid(){
                // Ordena por bay, row, stack
                const rows = [...patio.data].sort((a,b)=> a.bay-b.bay || a.row-b.row || a.stack-b.stack);
                gridBody.innerHTML = '';
                for(const c of rows){
                    const col = colorForSaida(c.saida);
                    const sw = `style="background: rgb(${Math.round(col[0]*255)}, ${Math.round(col[1]*255)}, ${Math.round(col[2]*255)});"`;
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${c.container}</td>
                        <td>${c.bay}</td>
                        <td>${c.row}</td>
                        <td>${c.stack}</td>
                        <td>${c.entrada}</td>
                        <td>${c.saida}</td>
                        <td><span class="sw" ${sw}></span>${statusLabel(c.saida)}</td>
                    `;
                    gridBody.appendChild(tr);
                }
                gridMeta.textContent = `${rows.length} itens`;
                updatePanelOffset();
            }
            
            rebuildInstances();
            rebuildGrid();
            
            // Buffers de cor
            const colorArr = new Float32Array(cube.verts*3);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf);
            gl.bufferData(gl.ARRAY_BUFFER, colorArr, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
            
            const tooltip = document.getElementById('tooltip');
            function multiplyMat4Vec4(m,v){
                const o = new Float32Array(4);
                for(let r=0;r<4;r++){ o[r]=m[r*4+0]*v[0]+m[r*4+1]*v[1]+m[r*4+2]*v[2]+m[r*4+3]*v[3]; }
                return o;
            }
            function worldToClip(pos, view, proj){
                const v = new Float32Array([pos[0], pos[1], pos[2], 1]);
                return multiplyMat4Vec4(proj, multiplyMat4Vec4(view, v));
            }
            
            function drawScene(){
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.06,0.07,0.09,1);
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                
                const aspect = canvas.width / canvas.height;
                const proj = mat4Perspective(Math.PI/4, aspect, 0.1, 1000);
                
                const cx = target[0] + panX, cy = target[1] + panY, cz = target[2];
                const ex = cx + dist*Math.cos(pitch)*Math.cos(yaw);
                const ey = cy + dist*Math.sin(pitch);
                const ez = cz + dist*Math.cos(pitch)*Math.sin(yaw);
                const view = mat4LookAt([ex,ey,ez], [cx,cy,cz], [0,1,0]);
                
                gl.uniformMatrix4fv(uProj, false, proj);
                gl.uniformMatrix4fv(uView, false, view);
                gl.uniform3f(uLightDir, -0.6, 1.0, 0.7);
                
                const mouse = currentMouse;
                let hovered = null, hoveredScreen = null;
                
                for(const inst of instances){
                    let model = mat4Identity();
                    model[0]*=inst.scale[0]; model[5]*=inst.scale[1]; model[10]*=inst.scale[2];
                    model = mat4Translate(model, inst.pos);
                    gl.uniformMatrix4fv(uModel, false, model);
                    
                    for(let i=0;i<cube.verts;i++){
                        colorArr[i*3+0]=inst.color[0];
                        colorArr[i*3+1]=inst.color[1];
                        colorArr[i*3+2]=inst.color[2];
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, colorArr);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf); gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, cube.verts);
                    
                    // Hover simples
                    const clip = worldToClip(inst.pos, view, proj);
                    const ndcX = clip[0]/clip[3], ndcY = clip[1]/clip[3];
                    const sx = (ndcX*0.5+0.5)*canvas.width;
                    const sy = (1-(ndcY*0.5+0.5))*canvas.height;
                    if(mouse && inst.kind==='container'){
                        const dx = sx - mouse.x, dy = sy - mouse.y;
                        if(Math.abs(dx) < 30 && Math.abs(dy) < 30){ hovered = inst; hoveredScreen = {x:sx, y:sy}; }
                    }
                }
                
                if(hovered){
                    tooltip.style.display = 'block';
                    tooltip.style.left = (hoveredScreen.x / (window.devicePixelRatio||1))+'px';
                    tooltip.style.top  = (hoveredScreen.y / (window.devicePixelRatio||1))+'px';
                    const m = hovered.meta;
                    tooltip.innerHTML = `
        <div><strong>${m.container}</strong></div>
        <div>Bay ${m.bay} • Row ${m.row} • Stack ${m.stack}</div>
        <div>Entrada: ${m.entrada}</div>
        <div>Saída: ${m.saida}</div>
      `;
                } else {
                    tooltip.style.display = 'none';
                }
                
                requestAnimationFrame(drawScene);
            }
            
            let currentMouse = null;
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                currentMouse = { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
            });
            canvas.addEventListener('mouseleave', () => currentMouse=null);
            
            requestAnimationFrame(drawScene);
            
            // Botões: otimizar e restaurar
            // document.getElementById('btnOpt').addEventListener('click', () => {
            //     patio = optimizeLayout(originalPatio);
            //     rebuildInstances();
            //     rebuildGrid();
            // });
            // document.getElementById('btnOrig').addEventListener('click', () => {
            //     patio = JSON.parse(JSON.stringify(originalPatio));
            //     rebuildInstances();
            //     rebuildGrid();
            // });
            
            // // Reorganizar a partir do estado atual (mantém os adicionados)
            // document.getElementById('btnOpt').addEventListener('click', () => {
            //     patio = optimizeLayout(patio);
            //     rebuildInstances();
            //     if (typeof rebuildGrid === 'function') rebuildGrid();
            // });
            
            // Substitua sua função por esta variante que também retorna moves (log)
            function optimizeLayoutWithMoves(p, { flipRowAxis = true } = {}){
                const { bays, rows, stacks, data } = p;
                
                // 1) Calcula layout alvo (mesma lógica atual)
                const asc = [...data].sort((a,b)=> a.saida.localeCompare(b.saida));
                const out = [];
                let end = asc.length;
                for (let r = rows; r >= 1 && end > 0; r--) {
                    const rowCap = bays * stacks;
                    const take = Math.min(rowCap, end);
                    const start = end - take;
                    const rowItems = asc.slice(start, end).sort((a,b)=> a.saida.localeCompare(b.saida));
                    end = start;
                    
                    const perBay = Array.from({length: bays}, () => []);
                    let k = 0;
                    for (let layer = stacks; layer >= 1 && k < rowItems.length; layer--) {
                        for (let b = 0; b < bays && k < rowItems.length; b++) {
                            perBay[b].push(rowItems[k++]); // topo primeiro
                        }
                    }
                    
                    for (let b = 0; b < bays; b++) {
                        const pile = perBay[b];
                        const n = pile.length;
                        for (let j = 0; j < n; j++) {
                            const c = pile[j];
                            const stack = n - j; // j=0 -> topo
                            const rowOut = flipRowAxis ? (rows - r + 1) : r;
                            out.push({
                                bay: b+1, row: rowOut, stack,
                                container: c.container, entrada: c.entrada, saida: c.saida
                            });
                        }
                    }
                }
                out.sort((a,b)=> a.bay-b.bay || a.row-b.row || a.stack-b.stack);
                
                // 2) Gera log de movimentações (simplificado e legível)
                // Regra: se posição mudou, loga "→" tirando da posição atual e "←" colocando na posição alvo.
                const curById = new Map();
                for (const c of data) curById.set(c.container, { bay:c.bay, row:c.row, stack:c.stack });
                const tgtById = new Map();
                for (const c of out)  tgtById.set(c.container, { bay:c.bay, row:c.row, stack:c.stack });
                
                const moves = [];
                // Remoções (→) de quem vai mudar
                for (const c of data) {
                    const tgt = tgtById.get(c.container);
                    if (!tgt) continue;
                    if (tgt.bay!==c.bay || tgt.row!==c.row || tgt.stack!==c.stack) {
                        moves.push(`${c.container} → Bay ${c.bay} Row ${c.row} (Stack ${c.stack})`);
                    }
                }
                // Colocações (←) em ordem de destino
                for (const c of out) {
                    const cur = curById.get(c.container);
                    if (!cur) { // novo que não existia (defensivo)
                        moves.push(`${c.container} ← Bay ${c.bay} Row ${c.row} (Stack ${c.stack})`);
                        continue;
                    }
                    if (cur.bay!==c.bay || cur.row!==c.row || cur.stack!==c.stack) {
                        moves.push(`${c.container} ← Bay ${c.bay} Row ${c.row} (Stack ${c.stack})`);
                    }
                }
                
                return { bays, rows, stacks, data: out, moves };
            }
            
            // Exemplo de uso no botão "Reorganizar (saída)"
            document.getElementById('btnOpt').addEventListener('click', () => {
                const res = optimizeLayoutWithMoves(patio);
                patio = { bays:res.bays, rows:res.rows, stacks:res.stacks, data:res.data };
                rebuildInstances();
                if (typeof rebuildGrid === 'function') rebuildGrid();
                
                // Integra com o painel do plugin (se existir)
                const list = document.getElementById('acp-moves-list');
                const count = document.getElementById('acp-moves-count');
                const panel = document.getElementById('acp-moves');
                if (list && count && panel) {
                    list.innerHTML = '';
                    res.moves.forEach(line => {
                        const li = document.createElement('li');
                        li.textContent = line;
                        list.appendChild(li);
                    });
                    count.textContent = `${res.moves.length} mov.`;
                    panel.hidden = false;
                }
            });
            
            // Restaurar do original (mantém a função de reset)
            document.getElementById('btnOrig').addEventListener('click', () => {
                patio = JSON.parse(JSON.stringify(originalPatio));
                rebuildInstances();
                if (typeof rebuildGrid === 'function') rebuildGrid();
            });
            
            // Inicializa offset do painel
            updatePanelOffset();
            
            window.integratePatioApi({
                getPatio(){ return patio; },
                setPatio(p){ patio = p; },
                rebuildInstances,
                rebuildGrid
            });
        })();
        
        
    </script>
</body>
</html>
