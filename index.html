<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="utf-8">
    <title>Pátio 3D (reorganizar)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body { height:100%; margin:0; background:#0e1116; color:#e5e7eb; font-family:system-ui, Segoe UI, Roboto, Arial; }
        #app { position:relative; height:100%; }
        canvas { display:block; width:100%; height:100%; }
        #tooltip {
            position:absolute; pointer-events:none; padding:6px 8px; background:#111827cc; color:#f9fafb; 
            border:1px solid #374151; border-radius:6px; font-size:12px; transform:translate(-50%, -120%); display:none; white-space:nowrap;
        }
        #legend {
            position:absolute; top:12px; left:12px; background:#111827dd; padding:10px 12px; border:1px solid #374151; border-radius:8px; font-size:12px;
        }
        .row { display:flex; gap:8px; align-items:center; margin-top:6px; }
        .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #374151; }
        #hud {
            position:absolute; bottom:12px; left:12px; background:#111827dd; padding:8px 10px; border:1px solid #374151; border-radius:8px; font-size:12px;
        }
        #actions {
            position:absolute; top:12px; right:12px; background:#111827dd; padding:10px 12px; border:1px solid #374151; border-radius:8px; display:flex; gap:8px;
        }
        button {
            background:#1f2937; color:#e5e7eb; border:1px solid #374151; padding:6px 10px; border-radius:6px; cursor:pointer;
        }
        button:hover { background:#111827; }
    </style>
</head>
<body>
    <div id="app">
        <canvas id="gl"></canvas>
        <div id="tooltip"></div>
        <div id="legend">
            <div><strong>Pátio 3D</strong> — bays × rows × stacks</div>
            <div style="margin-top:6px">Bays: 4, Rows: 4, Stacks: 3</div>
            <div class="row"><div class="swatch" style="background:#60a5fa"></div><div>Saída hoje</div></div>
            <div class="row"><div class="swatch" style="background:#34d399"></div><div>≤ 2 dias</div></div>
            <div class="row"><div class="swatch" style="background:#f59e0b"></div><div>≤ 4 dias</div></div>
            <div class="row"><div class="swatch" style="background:#9ca3af"></div><div>Mais longe</div></div>
        </div>
        <div id="actions">
            <button id="btnOpt">Reorganizar (saída)</button>
            <button id="btnOrig">Restaurar original</button>
        </div>
        <div id="hud">
            Arraste: orbitar • Shift+arraste: pan • Scroll: zoom
        </div>
    </div>
    <script>
        (async () => {
            // Estado de dados (original e corrente)
            const originalPatio = await fetch('data/load-patio.json').then(r => r.json()); // [attached_file:1]
            let patio = JSON.parse(JSON.stringify(originalPatio)); // corrente mutável // [attached_file:1]
            
            // Helpers de tempo e otimização
            const today = new Date().toISOString().slice(0,10); // [attached_file:1]
            function daysUntil(dateStr){
                const d = new Date(dateStr);
                const t = new Date(today);
                return Math.round((d - t)/(1000*60*60*24)); // [attached_file:1]
            }
            function colorForSaida(saida){
                const d = daysUntil(saida);
                if (d <= 0) return [0.38, 0.65, 0.98];
                if (d <= 2) return [0.20, 0.83, 0.60];
                if (d <= 4) return [0.96, 0.62, 0.05];
                return [0.62, 0.64, 0.67]; // [attached_file:1]
            }
            
            // incío da função de otimização simples
            function optimizeLayout(p, { flipRowAxis = true } = {}){
                const { bays, rows, stacks, data } = p;
                
                // Ordena ascendente (mais cedo primeiro)
                const asc = [...data].sort((a,b)=> a.saida.localeCompare(b.saida));
                
                const out = [];
                let end = asc.length; // vamos consumindo do fim (mais tardios) para ocupar o fundo
                
                for (let r = rows; r >= 1 && end > 0; r--) { // fundo -> frente
                    const rowCap = bays * stacks;
                    const take = Math.min(rowCap, end);
                    const start = end - take;
                    
                    // Itens desta row são os mais tardios restantes
                    const rowItems = asc.slice(start, end).sort((a,b)=> a.saida.localeCompare(b.saida));
                    end = start;
                    
                    // Distribui por bay em camadas do topo para a base
                    const perBay = Array.from({length: bays}, () => []);
                    let k = 0;
                    for (let layer = stacks; layer >= 1 && k < rowItems.length; layer--) {
                        for (let b = 0; b < bays && k < rowItems.length; b++) {
                            perBay[b].push(rowItems[k++]); // primeiro colocado nesta pilha será o topo
                        }
                    }
                    
                    // Emite contíguo: base=1 .. topo=n, topo recebe o mais cedo da pilha
                    for (let b = 0; b < bays; b++) {
                        const pile = perBay[b];
                        const n = pile.length;
                        for (let j = 0; j < n; j++) {
                            const c = pile[j];
                            const stack = n - j; // j=0 -> topo
                            const rowOut = flipRowAxis ? (rows - r + 1) : r; // espelha se o render usa row no eixo Z invertido
                            out.push({
                                bay: b+1, row: rowOut, stack,
                                container: c.container, entrada: c.entrada, saida: c.saida
                            });
                        }
                    }
                }
                
                out.sort((a,b)=> a.bay-b.bay || a.row-b.row || a.stack-b.stack);
                return { bays, rows, stacks, data: out };
            }
            
            // fim da função de otimização simples
            
            
            // WebGL básico
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
            if (!gl) { alert('WebGL não suportado'); return; } // [attached_file:1]
            function resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const w = canvas.clientWidth || canvas.parentElement.clientWidth;
                const h = canvas.clientHeight || canvas.parentElement.clientHeight;
                canvas.width = Math.floor(w * dpr);
                canvas.height = Math.floor(h * dpr);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize); resize(); // [attached_file:1]
            
            function mat4Identity(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
            function mat4Multiply(a,b){
                const o=new Float32Array(16);
                for(let r=0;r<4;r++){ for(let c=0;c<4;c++){ o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c]; } }
                return o;
            }
            function mat4Perspective(fovy, aspect, near, far){
                const f = 1/Math.tan(fovy/2), nf = 1/(near - far);
                const out = new Float32Array(16);
                out[0]=f/aspect; out[5]=f; out[10]=(far+near)*nf; out[11]=-1; out[14]=(2*far*near)*nf;
                return out;
            }
            function mat4Translate(m, v){ const [x,y,z]=v; const t=mat4Identity(); t[12]=x; t[13]=y; t[14]=z; return mat4Multiply(m,t); }
            function mat4LookAt(eye,center,up){
                const [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
                let zx=ex-cx, zy=ey-cy, zz=ez-cz; const zlen=Math.hypot(zx,zy,zz); zx/=zlen; zy/=zlen; zz/=zlen;
                let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx; const xlen=Math.hypot(xx,xy,xz); xx/=xlen; xy/=xlen; xz/=xlen;
                const yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
                const out=new Float32Array(16);
                out[0]=xx; out[1]=yx; out[2]=zx; out[4]=xy; out[5]=yy; out[6]=zy; out[8]=xz; out[9]=yz; out[10]=zz;
                out[12]=-(xx*ex+xy*ey+xz*ez); out[13]=-(yx*ex+yy*ey+yz*ez); out[14]=-(zx*ex+zy*ey+zz*ez); out[15]=1; return out;
            }
            
            const vs = `
  attribute vec3 aPos; attribute vec3 aNormal; attribute vec3 aColor;
  uniform mat4 uProj, uView, uModel; varying vec3 vNormal; varying vec3 vColor;
  void main(){ vec4 world = uModel * vec4(aPos,1.0); vNormal = mat3(uModel) * aNormal; vColor = aColor; gl_Position = uProj * uView * world; }`;
            const fs = `
  precision mediump float; varying vec3 vNormal; varying vec3 vColor; uniform vec3 uLightDir;
  void main(){ vec3 n=normalize(vNormal); float diff=max(dot(n, normalize(-uLightDir)),0.0); vec3 col=vColor*(0.35+0.65*diff); gl_FragColor=vec4(col,1.0); }`;
            function compile(type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
            function program(vsSrc, fsSrc){ const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vsSrc)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fsSrc)); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
            const prog = program(vs, fs); gl.useProgram(prog); // [attached_file:1]
            
            const cube = (() => {
                const p = [
                -0.5,-0.5, 0.5,  0.5,-0.5, 0.5,  0.5, 0.5, 0.5,
                -0.5,-0.5, 0.5,  0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
                -0.5,-0.5,-0.5, -0.5, 0.5,-0.5,  0.5, 0.5,-0.5,
                -0.5,-0.5,-0.5,  0.5, 0.5,-0.5,  0.5,-0.5,-0.5,
                -0.5,-0.5,-0.5, -0.5,-0.5, 0.5, -0.5, 0.5, 0.5,
                -0.5,-0.5,-0.5, -0.5, 0.5, 0.5, -0.5, 0.5,-0.5,
                0.5,-0.5,-0.5,  0.5, 0.5,-0.5,  0.5, 0.5, 0.5,
                0.5,-0.5,-0.5,  0.5, 0.5, 0.5,  0.5,-0.5, 0.5,
                -0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  0.5, 0.5,-0.5,
                -0.5, 0.5, 0.5,  0.5, 0.5,-0.5, -0.5, 0.5,-0.5,
                -0.5,-0.5, 0.5, -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,
                -0.5,-0.5, 0.5,  0.5,-0.5,-0.5,  0.5,-0.5, 0.5,
                ];
                const n = new Array(36).fill(0);
                // Normais por face (simplificado)
                for(let i=0;i<6;i++){
                    const nx = [0,0,0,-1,1,0][i]||0;
                    const ny = [0,0,0, 0,0,1][i]||0;
                    const nz = [1,-1,0,0,0,0][i]||0;
                    for(let t=0;t<6;t++){ n[(i*18)+t*3+0]=nx; n[(i*18)+t*3+1]=ny; n[(i*18)+t*3+2]=nz; }
                }
                return {positions:new Float32Array(p), normals:new Float32Array(n), verts:36};
            })();
            
            function makeVBO(data, loc, size){
                const buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(loc);
                gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
                return buf;
            }
            
            const aPos = gl.getAttribLocation(prog, 'aPos');
            const aNormal = gl.getAttribLocation(prog, 'aNormal');
            const aColor = gl.getAttribLocation(prog, 'aColor');
            
            const posBuf = makeVBO(cube.positions, aPos, 3);
            const nrmBuf = makeVBO(cube.normals, aNormal, 3);
            const colorBuf = gl.createBuffer();
            
            const uProj = gl.getUniformLocation(prog, 'uProj');
            const uView = gl.getUniformLocation(prog, 'uView');
            const uModel = gl.getUniformLocation(prog, 'uModel');
            const uLightDir = gl.getUniformLocation(prog, 'uLightDir'); // [attached_file:1]
            
            // Câmera e controles
            let yaw = -0.8, pitch = -0.4, dist = 22, target = [6, 2, 0];
            let panX = 0, panY = 0;
            let isDragging = false, lastX = 0, lastY = 0, isPanning = false;
            
            canvas.addEventListener('mousedown', e => { isDragging = true; isPanning = e.shiftKey; lastX=e.clientX; lastY=e.clientY; });
            window.addEventListener('mouseup', () => isDragging=false);
            window.addEventListener('mousemove', e => {
                if(!isDragging) return;
                const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX=e.clientX; lastY=e.clientY;
                if(isPanning){ const panSpeed = 0.01 * dist; panX -= dx*panSpeed; panY += dy*panSpeed; }
                else { yaw -= dx*0.005; pitch -= dy*0.005; pitch = Math.max(-1.4, Math.min(1.4, pitch)); }
            });
            canvas.addEventListener('wheel', e => { dist *= (1 + Math.sign(e.deltaY)*0.1); dist = Math.max(5, Math.min(80, dist)); }, {passive:true}); // [attached_file:1]
            
            // Layout e instâncias
            const BAY = patio.bays, ROW = patio.rows, STACK = patio.stacks; // [attached_file:1]
            const cellW = 3.0, cellL = 6.0, cellH = 2.5, gap = 0.3;
            
            let instances = [];
            function rebuildInstances(){
                instances = [];
                const byKey = new Map();
                for(const c of patio.data){ byKey.set(`${c.bay}-${c.row}-${c.stack}`, c); } // [attached_file:1]
                for(let b=1;b<=BAY;b++){
                    for(let r=1;r<=ROW;r++){
                        const x = (r-1)*(cellW+gap);
                        const z = (b-1)*(cellL+gap);
                        instances.push({ kind:'floor', pos:[x, -0.51, z], scale:[cellW,0.02,cellL], color:[0.17,0.20,0.25], meta:{ label:`Bay ${b}, Row ${r}` } });
                        for(let s=1;s<=STACK;s++){
                            const c = byKey.get(`${b}-${r}-${s}`);
                            if(!c) continue;
                            const y = (s-1)*(cellH+0.05) + cellH/2;
                            instances.push({
                                kind:'container',
                                pos:[x,y,z],
                                scale:[cellW*0.95, cellH*0.95, cellL*0.95],
                                color:colorForSaida(c.saida),
                                meta:{...c}
                            });
                        }
                    }
                }
            }
            rebuildInstances(); // [attached_file:1]
            
            const colorArr = new Float32Array(cube.verts*3);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf);
            gl.bufferData(gl.ARRAY_BUFFER, colorArr, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0); // [attached_file:1]
            
            const tooltip = document.getElementById('tooltip');
            function multiplyMat4Vec4(m,v){
                const o = new Float32Array(4);
                for(let r=0;r<4;r++){ o[r]=m[r*4+0]*v[0]+m[r*4+1]*v[1]+m[r*4+2]*v[2]+m[r*4+3]*v[3]; }
                return o;
            }
            function worldToClip(pos, view, proj){
                const v = new Float32Array([pos[0], pos[1], pos[2], 1]);
                return multiplyMat4Vec4(proj, multiplyMat4Vec4(view, v)); // [attached_file:1]
            }
            
            function drawScene(){
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.06,0.07,0.09,1);
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                
                const aspect = canvas.width / canvas.height;
                const proj = mat4Perspective(Math.PI/4, aspect, 0.1, 1000);
                
                const cx = target[0] + panX, cy = target[1] + panY, cz = target[2];
                const ex = cx + dist*Math.cos(pitch)*Math.cos(yaw);
                const ey = cy + dist*Math.sin(pitch);
                const ez = cz + dist*Math.cos(pitch)*Math.sin(yaw);
                const view = mat4LookAt([ex,ey,ez], [cx,cy,cz], [0,1,0]); // [attached_file:1]
                
                gl.uniformMatrix4fv(uProj, false, proj);
                gl.uniformMatrix4fv(uView, false, view);
                gl.uniform3f(uLightDir, -0.6, 1.0, 0.7);
                
                const mouse = currentMouse;
                let hovered = null, hoveredScreen = null;
                
                for(const inst of instances){
                    let model = mat4Identity();
                    model[0]*=inst.scale[0]; model[5]*=inst.scale[1]; model[10]*=inst.scale[2];
                    model = mat4Translate(model, inst.pos);
                    gl.uniformMatrix4fv(uModel, false, model);
                    
                    for(let i=0;i<cube.verts;i++){
                        colorArr[i*3+0]=inst.color[0];
                        colorArr[i*3+1]=inst.color[1];
                        colorArr[i*3+2]=inst.color[2];
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, colorArr);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf); gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, cube.verts);
                    
                    // Hover simples
                    const clip = worldToClip(inst.pos, view, proj);
                    const ndcX = clip[0]/clip[3], ndcY = clip[1]/clip[3];
                    const sx = (ndcX*0.5+0.5)*canvas.width;
                    const sy = (1-(ndcY*0.5+0.5))*canvas.height;
                    if(mouse && inst.kind==='container'){
                        const dx = sx - mouse.x, dy = sy - mouse.y;
                        if(Math.abs(dx) < 30 && Math.abs(dy) < 30){ hovered = inst; hoveredScreen = {x:sx, y:sy}; }
                    }
                }
                
                if(hovered){
                    tooltip.style.display = 'block';
                    tooltip.style.left = (hoveredScreen.x / (window.devicePixelRatio||1))+'px';
                    tooltip.style.top  = (hoveredScreen.y / (window.devicePixelRatio||1))+'px';
                    const m = hovered.meta;
                    tooltip.innerHTML = `
        <div><strong>${m.container}</strong></div>
        <div>Bay ${m.bay} • Row ${m.row} • Stack ${m.stack}</div>
        <div>Entrada: ${m.entrada}</div>
        <div>Saída: ${m.saida}</div>
      `;
                } else {
                    tooltip.style.display = 'none';
                }
                
                requestAnimationFrame(drawScene);
            }
            
            let currentMouse = null;
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                currentMouse = { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
            });
            canvas.addEventListener('mouseleave', () => currentMouse=null);
            
            requestAnimationFrame(drawScene);
            
            // Botões: otimizar e restaurar
            document.getElementById('btnOpt').addEventListener('click', () => {
                patio = optimizeLayout(originalPatio);
                rebuildInstances();
            }); // [attached_file:1]
            document.getElementById('btnOrig').addEventListener('click', () => {
                patio = JSON.parse(JSON.stringify(originalPatio));
                rebuildInstances();
            }); // [attached_file:1]
        })();
    </script>
</body>
</html>
